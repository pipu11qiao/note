微前端的一些问题？

* 微前端实现的原理
* 乾坤和frame异同
* 隔离
* 消息通信
* 部署

#### 微前端的价值

######  技术栈落后、编译部署慢

微前端架构具备以下几个核心价值：

* 技术栈无关：主框架不限制接入应用的技术栈，子应用具备完全自主权
* 独立开发、独立部署：子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
* 独立运行时：每个子应用之间状态隔离，运行时状态不共享
* 微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用( Frontend Monolith )后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。

微前端的方案

* nginx 路由转发 MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。
* iframe 嵌套 实现简单 (跨域通信问题）
* SPA 组件 技术栈强耦合
* 组合是应用路由分发

微前端为什么不用 iframe

* url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
* UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
* 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
* 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

* 组合路由的的分发方式

基于single spa 的两种方式
* 乾坤 html entry
* systemjs js entry

粒度不同 qiankun是微应用 systemjs 是微模块

####  js 隔离

* legacySandBox
* proxySandBox
* snapshotSandBox。

###### legacySandBox

legacySandBox 的核心思想是什么呢？legacySandBox 的本质上还是操作 window 对象，但是他会存在三个状态池, 分别用于子应用卸载时还原主应用的状态和子应用加载时还原子应用的状态

* addedPropsMapInSandbox： 存储在子应用运行时期间新增的全局变量，用于卸载子应用时还原主应用全局变量；
* modifiedPropsOriginalValueMapInSandbox：存储在子应用运行期间更新的全局变量，用于卸载子应用时还原主应用全局变量；
* currentUpdatedPropsValueMap：存储子应用全局变量的更新，用于运行时切换后还原子应用的状态；

运行时也会操作window

###### proxySandbox

多实例场景
可见，因为 proxySandBox 不直接操作 window，所以在激活和卸载的时候也不需要操作状态池更新 / 还原主子应用的状态了。相比较看来，proxySandBox 是现阶段 qiankun 中最完备的沙箱模式，完全隔离了主子应用的状态，不会像 legacySandBox 模式下在运行时期间仍然会污染 window。
运行时也不会操作window

###### snapshotSandBox

最后一种沙箱就是 snapshotSandBox，在不支持 Proxy 的场景下会降级为 snapshotSandBox，如同他的名字一样，snapshotSandBox 的原理就是在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。

#### css隔离

##### 约定是编程

##### css in js 

CSS隔离：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。
而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。

### 微前端改造决策链

* 是否要做
* 是否要模块联邦
* 是否有老项目牵挂
* 是否全是老项目

带来维护和重构的问题
