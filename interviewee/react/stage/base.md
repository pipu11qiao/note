分为三个过程

调度
调和 异步可终端
提交 同步不可中断


调度的过程

```javascript
render
legacyRenderSubtreeIntoContainer
legacyCreateFromDOMContainer
createLegacyRoot
ReactDOMBlockingRoot
createRootImpl
createContainer
createFiberRoot
createHostRootFiber
createFiber
FiberNode
```

调和过程
```javascript
unbatchedUpdates
updateContainer
requestCurrentTimeForUpdate
sheduleUpdateOnFiber
performSyncWorkOnRoot
workLoopSync
performUnitOfWork
beginWork
updateHostRoot
processUpdateQueue

reconcileChildren
reconcileChildFibers
reconcileSingleElement // reconcileChildrenArray
createFiberFromElement // placeChild
completeUnitOfWork
completeWork
createInstance
createElement
appendAllChildren
```
提交阶段
```javascript
finishSyncRender
commitRoot
runWithPriority
Unstable_runWithPriority
commitRootImpl
commitMutationEffects
commitPlacement
insertOrAppendPlacementNodeIntoContainer
appendChildToContainer
appendChild
```
执行React任务和页面响应交互这两件事情是互斥的，但因为Scheduler可以利用时间片中断React任务，然后让出线程给浏览器去绘制，所以一开始在fiber树的构建阶段，拖动方块会得到及时的反馈。但是后面卡了一下，这是因为fiber树构建完成，进入了同步的commit阶段，导致交互卡顿。分析页面的渲染过程可以非常直观地看到通过时间片的控制。主线程被让出去进行页面的绘制（Painting和Rendering，绿色和紫色的部分）
