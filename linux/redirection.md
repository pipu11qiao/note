## linux 输入/输出重定向介绍

#### 介绍

linux 内置的重定向能力提供了很多工具,使你更加轻松地完成各种各样的任务。无论你是通过命令行在编写复杂的软件或是在完成文件管理，懂得在当前的环境中如何去操作不同的输入/输出**流**将会极大的提升你的产出能力。

### 流（stream）的种类

在linux环境下，输入和输出分为三种类型的流，分别是：

* 标准输入（stdin）
* 标准输出（stdout）
* 标准错误（stderr）
这些流也可以用数字表示

* stdin(0)
* stdout(1)
* stderr(2)

在用户和终端的标准交互过程中，标准输入（stdin）是通过用户键盘输入，标准输出（stdout）和标准错误（stderr）在用户的终端以文字显示。总结来说，这三种流都被用做标准流。

### 标准输入

标准输入流

标准输入流一般负责从用户想程序传递数据。那些需要标准输入的程序一般通过一些设备，如键盘来接受输入。标准输入遇到EOF（end of file）就会停止，就像她的名字，EOF说明没有要读取的数据了。


可以通过运行**cat**来查看标准输入的行为。cat命令代表串联，意思是连接或者混合一些文件。通用用来拼接两个文件。当你只输入cat命令本身，它会循环调用提示命令（prompt)

```
cat

```
在它打开，敲入一些数字：

```
1
2
3
ctrl-d

```
当你敲入一个数字并按下回车的时候，你就是在想cat程序发送标准输入，也被称作输入。相应的，cat程序会将你的输入当做标准输出展示。

EOF 可以在用户输入ctrl + d 的时候被输入。在cat程序接收到EOF后程序停止。

### 标准输出

标准输出写入程序生成的数据。当标准输出流没有被重定向的时候，它将会被输出到终端。试一下下面的例子：

```
echo Sent to the terminal through standard output

```

如果没有使用其他额外的属性，**echo**命令会展示通过命令行传递的所有的参数。 参数就是程序接受到的数据

不带任何参数的运行echo

```
echo

```

它将会返回一个空行，因为没有输入参数。

### 标准错误

标准错误写入由程序生成的在改程序执行时出现的一些失败的错误数据。类似标准输出，该流的默认展示的地方在终端。

当一个程序的标准错误流流向下一个程序时，传递的数据（包含程序错误信息）被同时发送到终端。

让我们使用**ls**命令来看一个标准错误的简单例子，**ls**是展示一个文件夹内的内容

当你不带参数运行ls，它会展示文件夹内的内容。如果传入一个文件夹名当参数，将会列举提供的文件夹内的内容。

```
ls %

```
由于%这个文件夹不存在，会输出如下的标准错误

```
ls: %: No such file or directory

```

### 流重定向

在linux中没个流都包含重定向命令。这些命令向一个文件中写入标准输出。如果作为目标（被一个尖括号或者两个尖括号标识）的文件不存在,会优先创建一个以该文件名为名字的文件来写入。

一个尖括号重写目标文件的内容。
 
#### 重写

* > -- 标准输出
* > -- 标准输入
* 2>> -- 标准错误

两个尖括号不会重写目标文件已存在的内容

* >> -- 标准输出
* << -- 标准输入
* 2>> -- 标准错误

##### 例子

```

cat > write_to_me.txt
a
b
c
ctrl-d

```
在这里，**cat**被用来写入文件，内容是循环提示的结果。

查看该文件的泥工

```

cat write_to_me.txt

```

内容是

```

a
b
c

```

重新定向cat写入该文件，这次如数3个数字


```
cat > write_to_me.txt
1
2
3
ctrl-d

```

当你用cat命令查看该文件时，会看到你输入的数字

```

1
2
3

```
早泄的内容不存在了因为单个尖括号是重写的命令。

再来一次cat命令这次用双尖括号

```

cat >> write_to_me.txt
a
b
c
ctrl-d

```
查看文件

```

1
2
3
a
b
c


```
##### Pipes

管道(pipe)命令用来让流从一个程序到另个程序。当一个程序的标准输出被发送到另一个程序是，第一个程序的产生的被另外程序接收到的数据不会再终端展示。只有被第二个程序返回的过滤后的数据会展示。

linux 中 pipe命令是一个竖线

```
* | *
*
```

一个例子：
```
ls | less

```
这组命令将**ls**展示当前文件夹内容的输出输送到**less**程序,less将发送给他的数据以每次一行的形式展示。

 **ls** 正常来说会将文件夹内容多行展示。当你通过less运行它,每个入口会在一个新行防止
虽然pipe的功能看上去和>以及>>（标准输出重定向）相类似，特殊之处在于pipe是将数据从一个程序传递到下一个程序，而>和>>是将数据重定向的唯一的文件。

##### Filters

Filters 过滤器是一些改变管道和输出内容的命令。需要注意的是管道命令也是一些标准的linux命令，可以脱离pipe独立运行：

* find 返回与传入的参数相匹配的文件的文件名
* grep  返回出入字符表达式匹配的文本
* tee  将标准输出重定向到标准输出和一个或多个文件
* tr 找到并替代
* wc 给字符、行和单词计数

##### 例子

到这已向你介绍了**重定向（redirection）**,管道（pipe）和**基本过滤（filters）**,让我们看一些基本的重定向表达式和例子

######  命令 > 文件

这个表达式将一个命令的标准输出进行重定向

```
ls ~ > root_dir_contents.txt

```

上述命令会将你系统的root文件夹中的内容作为标准输出将其写入名称为root_dir_contents的文件中。它会删除原先的文件件内容，因为用的是单个尖括号

###### 命令> /dev/null

/dev/null 是一个特殊的文件用来丢弃发送给他的任意数据，它被用用丢弃没用的或者会妨碍一个程序或命令功能的标准输出。所有的被发送到/dev/null的输出都会被忽略。
在将来，当你编写shell脚本时，你会发现将标准输出和标准错误重定向到/dev/null的实际使用

```
ls > /dev/null
```
这个命令会忽略ls命令产生的标准输出结果

###### 命令 | 命令

把一个命令的标准输出重定向到另一个命令的标准输入。

```
find /var lib | grep deb
```
这个命令会搜索 /var文件夹以及它的所有子级文件的文件名和扩展名中匹配字符串deb,返回这些文件的路径，并在匹配的内容红色高亮显示

###### 命令 | tee file

这个表达式(包含tee命令的),将命令行产生的标准输出重定向到文件，并且在终端展示。 如果文件不存在会创建文件。

在这个表达式的环境中，tee命令典型的是用来查看改程序的输出并且把它们写入文件。

```
wc /etc/magic | tee magic_cout.txt
```

这将magic文件（该文件是Linux shell 用来决定文件类型）中统计的字符、行数和单词的数量输送到tee命令,该命令会将wc命令产生的输出分成两个重定向，发送到终端展示和magic_count.txt文件。对于tee命令来说，可以想象成字母T，下面的竖线是初始的数据，顶部部分是数据被分成了两份（标准输出和终端）

多级的管道可以用来即将输出重定向到多级的命令和过滤

###### command | command | command >> file

这个表达式从第一个命令获得的输出并在后续两个命令中过滤，最后将其追加到目标文件中

```
ls ~ | grep *tar | tr e E >> ls_log.txt
```

这个表达式开始时运行ls命令在root文件夹，并将结果输送到grep命令，在文件列表中找到文件名或扩展名中包含tar字符的。

grep产生的结果被输送到tr命令，将结果中的e替换成E（因为e是第一个参数而E是第二个参数）,最终的结果会被追加到ls_log.txt文件，如果该文件不存在将会被创建。

### 总结

学习使用Linux内置的重定向指令会让人有点气馁，但是当你完成该教程后你会很好地掌握该技能。现在你已经了解重定向和管道基本的工作原理，你将有能力涉足使用shell脚本世界，那将会是该教程中强调的程序和表达式更假的便捷。

如果你想深入了解该教程中涉及的命令，你可以使用man命令来，例如

```
man tee | less
```
这将会为你展示tee程序的所有使用的信息。你可以使用这个命令来查看任何linux的命令的信息和用法

谷歌搜索哪些特殊的命令可以促进你完成命令行的功能。
#### 参考文章
[An Introduction to Linux I/O Redirection](https://www.digitalocean.com/community/tutorials/an-introduction-to-linux-i-o-redirection)
