### Bash Shell 使用环境 ###

当我们登录系统时，屏幕上会有一些说明文字，告知我们的Linux版本，或者在我们登入的时候给一些讯息和欢迎文字。我们习惯的环境变量、命令别名，在登入的时候设定好。这些设定值可以分为系统整体设定值和各人喜好设定值。

#### 绝对路径和相对路径 ####
路径的概念在bash shell使用过程中很重要，分为绝对路径和相对路径。这与PATH变量关系很大,如果PATH设定不正确，下达指令就必须要以一长列的指令连带目录列出来。 所谓的『绝对路径』就是以根目录开始写入到档案的一种命令写定方法。执行命令的时候要根据命令程序所在的文件夹位置来访问程序。例如使用/bin 目录下的more程序来查看家目录中的/home/test/.bashrc 档案

```
cd /home/test
/bin/more .bashrc
```

其中 /bin/more 指令就是通过绝对路径来执行more程序，我们也可以通过相对路径定位到more程序，当前的/home/test 目录向上两级就是根目录/,

```
../../bin/more .bashrc
```
在bash的执行过程中为什么不在当前目录下搜索执行程序？

相对路径中有.和..两个关键字，.表示当前目录，..表示上一级目录。为什么不在当前目录下搜索执行程序，这是因为安全考虑，因为系统预设是允许任何人在/tmp底下写入任何档案，万一有居心不良的使用者在/tmp目录下写一个名为ls的木马，如果以roo身份登录执行该木马。。。

#### 登录讯息显示数据： /etc/issue, /etc/motd ####
在mac上是没有的需要手动创建
/etc/issue  (创建了也没用，略过这个等哪天用到在回来搞吧)
在issue中有一些关键字，能够获取当前的系统信息。
/etc/motd 这个文件创建了以后再mac能用！

```
# sudo vim /etc/motd
# cat /etc/motd
hello test motd file.
#

```
新打开一个终端窗口，结果:
```
Last login: Fri Jul 26 23:58:47 on ttys001
hello test motd file.
#
```
#### 环境设定档，bashrc,~/.bashrc, ~/.profile, profile...,/etc/inputrc,source ####

bash的环境变量等数据,可以有系统规划和个人习惯。一般只需设置个人设定部分就好了。

* 系统设定值 有些文件会根据系统的不同摆放位置和内容不一样
就是每个用户进入bash shell 之后会先读取的设定档 预设的设定档案有下列几个：
    * /etc/sysconfig/i18n 语系变量设定文件,一般会在个人设定中设置
    * /etc/profile 设定几个重要变量，[PATH,USER,MAIL...]
    * /etc/bashrc
    * /etc/profile.d/*.sh
        /etc/profile.d 是一个目录，里面针对bash及C-shell规范了一些数据。
    * /etc/man.config 规范了使用man命令的时候，man page的寻找路径，最重要的是MANPATH变量的设定

* 个人设定值 在家目录的几个隐藏文件中设置
    * ~/.bash_profile,~/.bash_login ~/.profile
        这三个档案通常只要一个就够了，一般预设是~.bash_profile的档名存在。这个档案可以定义个人化的路径（PATH）与环境变量等等。会有读取的顺序 优先~/.bash_profile 再 ~/.bash_login 再 ~/.profile
    * ~/.bashrc 一般命令别名、路径等都写入这个。这个档案在每次执行 shell script 的时候都会被重新使用一遍，而~/.bash_profile 则只有在登入的时候会被读取一次。
    * ~/.bash_history 历史指令记录
    * ~/.bash_logout 这个档案记录了当我注销bash后，系统再帮我做完什么动作后才离开。预设是清楚屏幕讯息

我们知道了设定的规范，系统读取档案的顺序
1. 先读取/etc/profile
2. 再读取 ~/.bash_profile
3. 再读取 ~/.bashrc

所在当我们登入bash后，最终读取的文档是 ~/.bashrc ，也就是说在~/.bashrc里面的设定会是最终的设定值。
我们在通过编辑~/.bashrc文件来进行bash变量等操作的配置，可以通过重新登入bash来重读bashrc，也可以通过 source 和 . 来在不登出的情况下，加载bashrc

```
source ~/.bashrc]
. ~/.bashrc
```
* login shell 与 no-login shell
基本上,就字面上的意义来解释的话,所谓的 loign shell 指的就是当使用者登入 Linux 系统时,所取得的那个 shell 称为 login shell。 当登入后,再去执行其它的 shell 时,其它的 shell 就是 non-login shell 了

#### 终端机的环境设定 ####

我们在登入终端机terminal,会取得字符设定的功能，如修改删除命令行字符的按键。可以利用stty来查看和设定这部分内容，具体请`man stty`

除了stty之外，bash还有自己的一些终端机设定。那就是利用 set 来设定的! 我们
之前提到一些变量时,可以利用 set 来显示,除此之外,其实 set 还可以帮我们设定整个指令输出/输入的环境。 例如记录历史命令、显示错误内容等等。

#### 万用字符与特殊符号 ####
bash中支持一些万用符号（wild card），下面列出一些常用的：
符号 |　内容
\*| 万用字符,代表 0 个或多个字符(或数字)
\?| 万用字符,代表『一定有』一个字母
\# |批注,这个最常被使用在 script 当中,视为说明!
\\ |跳脱符号,将『特殊字符或万用字符』还原成一般字符
\| |分隔两个管线命令的界定;
\; |连续性命令的界定(注意!与管线命令并不相同)
\~ |使用者的家目录
\$ |亦即变量之前需要加的变量取代值
\& |将指令变成背景下工作
\! |逻辑运算意义上的『非』 not 的意思!
\/ }路径分隔的符号
\>, >> |输出导向,分别是『取代』与『累加』
\' |单引号,不具有变量置换的功能
\" |具有变量置换的功能!
\` \` |两个 \`中间为可以先执行的指令!
\( ) |在中间为子 shell 的起始与结束
\[ ] |在中间为字符的组合
\{ } |在中间为命令区块的组合!

屏幕按键　｜　执行结果
-- | --
Ｃ+ c | 终止目前命令
C + d | 输入结束（ＥＯＦ）
C + m | enter
C + s | 暂停屏幕输出
C + q | 恢复屏幕输出
C + u | 在提示字符下，将整列命令删除
C + z | 暂停目前的命令

我们来提几个简单的例子

```
 ls test* <==那个 * 代表后面不论接几个字符都予以接受
 ls test? <==那个 ? 代表后面『一定』要接『一个』字符
 ls test??? <==那个 ??? 代表『一定要接三个』字符!
 cp test[1-5] /tmp
# 将 test1, test2, test3, test4, test5 若存在的话,就拷贝到 /tmp
 cp test[!1-5] /tmp
# 只要不是 test1, test2, test3, test4, test5 之外的其它 test? ,
# 若存在的话,就拷贝到 /tmp
 cd /lib/modules/`uname -r`/kernel/drivers
# 被 ` ` 括起来的内容『会先执行』
```




